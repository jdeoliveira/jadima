/**
 * $theClass.getClassName() Jgm Stub
 *
 * IMPORTANT: THIS FILE IS AUTOGENERATED BY THE JGM STUB GENERATOR.
 * DO NOT EDIT!!!
 *
 * @todo: considerar excepciones lanzadas por los metodos reales. El objeto Method lanza en
 * ese caso un InvocationTargetException. Habria que desenvolver la excepcion real, "castearla"
 * a la clase correspondiente y volver a lanzarla.
 *
 */

package $theClass.getPackageName();

public #isAbstract($theClass) class $className #extends($theClass) #interfaces($theClass)
{

#fields($theClass)

#foreach ($method in $theClass.getMethods())

    // ITERANDO METODO No.$velocityCount

    #if($method.isPublic() || $method.isProtected() || $method.getName().equals("<init>"))

    	//Es un metodo publico o protected o constructor

        #methodSignature($method)
        
        #if($method.isAbstract()) 
            ; //El metodo es abstracto 
        #else 
            //el metodo no es abstracto
            {

            #if($util.isConstructor($method)) 
                #superCall($theClass) 
            #end
                //JGM: Do nothing, this method will never be executed
                #if(!($method.getReturnType().toString().equals("void")))
                    #if($primitivesNull.containsKey($method.getReturnType().toString()))
                        return $primitivesNull.get($method.getReturnType().toString()) ;
                    #else
                        return ($util.replaceInnerClass("$method.getReturnType()")) null ;
                    #end
                #end
            }
        #end
    #else 
        //NO ES PUBLICO
    #end
#end

    //JGM: Here starts the public and named inner classes declaration
    #foreach ($innerClass in $theNamedInnerClasses)

        #if($innerClass.isInterface())
            //ES interface
            #set($isInnerInterface = true)
        #else 
            //NOOOO ES interface  
            #set($isInnerInterface = false)
        #end

        #isPublic($innerClass) #isProtected($innerClass) #if($util.isStaticInnerClass($theClass, $innerClass)) static #end #isAbstract($innerClass) #if($isInnerInterface) interface #else class #end $util.extractClassName($innerClass) #if($isInnerInterface) #extendsInterface($innerClass) #else #extends($innerClass) #interfaces($innerClass) #end
        {

        //antes de field

        #fields($innerClass)

        //antes de iterar los metodos

        #foreach ($innerMethod in $innerClass.getMethods())

            // ITERANDO METODO No.$velocityCount
            // Nombre: $innerMethod.getName()
            // Is inner interface: #if($isInnerInterface) YEAH #else no #end

            #if((!$innerMethod.getName().equals("<clinit>")) && ($innerMethod.getName().indexOf('$') == -1) && !$innerMethod.isPrivate() && !($isInnerInterface) && !($util.hasAnonymousClassParameters($innerMethod)))

                //Es un metodo publico o protected o constructor
                #if($util.isConstructor($innerMethod))
                    #innerConsSignature($innerMethod $theClass)
                #else
                    #innerMethodSignature($innerMethod)
                #end

                #if($innerMethod.isAbstract()) 
                    ; //El metodo es abstracto 
                #else 
                    //el metodo no es abstracto
                    {

                    #if($util.isConstructor($innerMethod)) 
                       //DOING SUPER INNER CALL
                        #innerSuperCall($innerClass $theClass) 
                    #end
                        //JGM: Do nothing, this method will never be executed
                        #if(!($innerMethod.getReturnType().toString().equals("void")))
                            #if($primitivesNull.containsKey($innerMethod.getReturnType().toString()))
                                return $primitivesNull.get($innerMethod.getReturnType().toString()) ;
                            #else
                                return ($util.replaceInnerClass("$innerMethod.getReturnType()")) null ;
                            #end
                        #end
                    }
                #end
            #else 
                //NO ES PUBLICO
            #end

            //Here starts inner-inner class declarations

            //Here ends inner-inner class declarations

        #end
        }
    #end

    //JGM: Inner classes declaration ended

    //JGM: Here starts anonymous inner classes declaration

    #foreach($anonInnerClass in $theAnonymousInnerClasses) 
        
        private $util.replaceInnerClass($anonInnerClass.getSuperClass().getClassName()) jgm_anon_inner_$velocityCount = #anonInnerNew($anonInnerClass $theClass) {

            #foreach ($anonInnerMethod in $anonInnerClass.getMethods())

                // ITERANDO METODO No.$velocityCount
                // Nombre: $anonInnerMethod.getName()

                #if(($anonInnerMethod.isPublic() || $anonInnerMethod.isProtected()) && (!($anonInnerMethod.getName().equals("<init>"))))

                    //Es un metodo publico o protected o constructor
                    #anonInnerMethodSignature($anonInnerMethod)

                    #if($anonInnerMethod.isAbstract()) 
                        ; //El metodo es abstracto 
                    #else 
                        //el metodo no es abstracto
                        {

                            //JGM: Do nothing, this method will never be executed
                            #if(!($anonInnerMethod.getReturnType().toString().equals("void")))
                                #if($primitivesNull.containsKey($anonInnerMethod.getReturnType().toString()))
                                    return $primitivesNull.get($anonInnerMethod.getReturnType().toString()) ;
                                #else
                                    return ($util.replaceInnerClass("$anonInnerMethod.getReturnType()")) null ;
                                #end
                            #end
                        }
                    #end
                #else 
                    //NO ES PUBLICO
                #end
            #end
        };
    #end

    //JGM: Anonymous inner classes declaration ended
}
//JGM: Template end